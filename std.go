package sqlee

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
)

// Std implements the `Essentials` interface with only using the standard
// library `database/sql.DB` internally. This should provide great cross-
// database support.
//
// It is fully transparent and non-magical (e.g. the arguments, etc. are just
// passed into the standard library).
//
// The primary use case of `Std` is to drastically reduce error checking.
type Std struct {
	db *sql.DB
}

var _ Essentials = (*Std)(nil) // *Std implements Essentials

// NewStd initializes a new std
func NewStd(db *sql.DB) *Std {
	return &Std{
		db: db,
	}
}

// Exec will execute the query with it's argument against the database and
// returns any occurring errors.
func (s *Std) Exec(ctx context.Context, query string, args ...interface{}) error {
	_, err := s.ExecRes(ctx, query, args...)
	return err
}

// ExecTx is the same as `Exec` but uses the passed transaction `tx` to execute
// the operations.
func (s *Std) ExecTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) error {
	_, err := s.ExecResTx(ctx, tx, query, args...)
	return err
}

// ExecID executes the query with it's arguments against the database and
// returns any occurring errors.
//
// Additionally it returns the integer generated by the database in response to
// a command. Typically this will be from an "auto increment" column when
// inserting a new row. Not all databases support this feature, and the syntax
// of such statements varies.
func (s *Std) ExecID(ctx context.Context, query string, args ...interface{}) (lastInsertID int64, err error) {
	res, err := s.ExecRes(ctx, query, args...)
	if err != nil {
		return 0, err
	}

	lastInsertID, err = res.LastInsertId()
	if err != nil {
		return 0, err
	}

	return
}

// ExecIDTx is the same as `ExecID` but uses the passed transaction `tx` to
// execute the statement.
//
// Additionally it returns the integer generated by the database in response to
// a command. Typically this will be from an "auto increment" column when
// inserting a new row. Not all databases support this feature, and the syntax
// of such statements varies.
func (s *Std) ExecIDTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (lastInsertID int64, err error) {
	res, err := s.ExecResTx(ctx, tx, query, args...)
	if err != nil {
		return 0, err
	}

	lastInsertID, err = res.LastInsertId()
	if err != nil {
		return 0, err
	}

	return
}

// ExecAffected executes the query with it's arguments against the database and
// returns any occurring errors.
//
// Additionally it returns the number of rows affected by an update, insert, or
// delete. Not every database or database driver may support this.
func (s *Std) ExecAffected(ctx context.Context, query string, args ...interface{}) (rowsAffected int64, err error) {
	res, err := s.ExecRes(ctx, query, args...)
	if err != nil {
		return 0, err
	}

	rowsAffected, err = res.RowsAffected()
	if err != nil {
		return 0, err
	}

	return
}

// ExecAffectedTx is the same as `ExecAffected` but uses the passed transaction
// `tx` to execute the statement.
//
// Additionally it returns the number of rows affected by an update, insert, or
// delete. Not every database or database driver may support this.
func (s *Std) ExecAffectedTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (rowsAffected int64, err error) {
	res, err := s.ExecResTx(ctx, tx, query, args...)
	if err != nil {
		return 0, err
	}

	rowsAffected, err = res.RowsAffected()
	if err != nil {
		return 0, err
	}

	return
}

// ExecRes executes the query with it's arguments against the database and
// returns any occurring errors.
func (s *Std) ExecRes(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}

	res, err := s.ExecResTx(ctx, tx, query, args...)
	if err != nil {
		rlbErr := tx.Rollback()
		if rlbErr != nil {
			return nil, fmt.Errorf("sqle: multiple errors occurred: %q followed by tx.Rollback error: %q", err.Error(), rlbErr.Error())
		}

		return nil, err
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return res, nil
}

// ExecResTx is the same as `ExecRes` but uses the passed transaction `tx` to
// execute the statement.
func (s *Std) ExecResTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (res sql.Result, err error) {
	var stmt *sql.Stmt
	stmt, err = tx.PrepareContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer func() {
		closeErr := stmt.Close()
		if closeErr != nil && err == nil {
			res = nil
			err = closeErr
		}
	}()

	res, err = stmt.ExecContext(ctx, args...)
	if err != nil {
		return nil, err
	}

	return
}

// UnsafeExecBatch runs `Exec` without arguments for every entry in the
// `statements` collection.
//
// This method IS NOT SAFE AGAINST SQL-INJECTION. Use it only with trusted
// input!
func (s *Std) UnsafeExecBatch(ctx context.Context, statements []string) error {
	for _, stmt := range statements {
		err := s.Exec(ctx, stmt)
		if err != nil {
			return err
		}
	}

	return nil
}

// UnsafeExecBatchTx is the same as `UnsafeExecBatch` but uses the passed
// transaction `tx` to execute the statements.
//
// This method IS NOT SAFE AGAINST SQL-INJECTION. Use it only with trusted
// input!
func (s *Std) UnsafeExecBatchTx(ctx context.Context, tx *sql.Tx, statements []string) error {
	for _, stmt := range statements {
		err := s.ExecTx(ctx, tx, stmt)
		if err != nil {
			return err
		}
	}

	return nil
}

// Select selects the `query` string from the database. The `args` interface
// slice should contain all primitive value arguments. The `dest` interface
// slice should contain a collection of pointer to primitive types. The results
// of the query will be saved into these pointers.
func (s *Std) Select(ctx context.Context, query string, args []interface{}, dest []interface{}) error {
	_, err := s.SelectExists(ctx, query, args, dest)
	return err
}

// SelectTx is the same as `Select` but uses the passed transaction `tx` to
// execute the statement.
func (s *Std) SelectTx(ctx context.Context, tx *sql.Tx, query string, args []interface{}, dest []interface{}) error {
	_, err := s.SelectExistsTx(ctx, tx, query, args, dest)
	return err
}

// SelectExists is the same as `Select`, but additionally returns an boolean
// value, whether or not the query returned a row.
func (s *Std) SelectExists(ctx context.Context, query string, args []interface{}, dest []interface{}) (exists bool, err error) {
	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return false, err
	}

	exists, err = s.SelectExistsTx(ctx, tx, query, args, dest)
	if err != nil {
		rlbErr := tx.Rollback()
		if rlbErr != nil {
			return false, fmt.Errorf("sqle: multiple errors occurred: %q followed by tx.Rollback error: %q", err.Error(), rlbErr.Error())
		}

		return false, err
	}

	err = tx.Commit()
	if err != nil {
		return false, err
	}

	return
}

// SelectExistsTx is the same as `SelectExists` but uses the passed transaction
// `tx` to execute the statement.
func (s *Std) SelectExistsTx(ctx context.Context, tx *sql.Tx, query string, args []interface{}, dest []interface{}) (exists bool, err error) {
	if len(dest) == 0 {
		return false, errors.New("sqle: no dest to scan to")
	}

	var stmt *sql.Stmt
	stmt, err = tx.PrepareContext(ctx, query)
	if err != nil {
		return false, err
	}
	defer func() {
		closeErr := stmt.Close()
		if closeErr != nil && err == nil {
			exists = false
			err = closeErr
		}
	}()

	if len(args) > 0 {
		err = stmt.QueryRowContext(ctx, args...).Scan(dest...)
	} else if len(args) == 0 {
		err = stmt.QueryRowContext(ctx).Scan(dest...)
	}

	if err != nil {
		if err == sql.ErrNoRows {
			return false, nil
		}
		return false, err
	}

	return true, nil
}

// SelectRange selects a range of results from the database, defined by the
// `query` and it's arguments. The `args` interface slice should contain all
// primitive value arguments. The `dest` interface slice should contain a
// collection of pointer to primitive types. The results of the query will be
// saved into these pointers.
//
// As soon as one row has been loaded the `handleRow` callback will be called.
// It is the package caller's responsibility to copy the values from the `dest`
// pointers into another data structure. After returning the `handleRow`
// function the values of `dest` will be overwritten with the next row's
// values.
func (s *Std) SelectRange(ctx context.Context, query string, args []interface{}, dest []interface{}, handleRow func()) error {
	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	err = s.SelectRangeTx(ctx, tx, query, args, dest, handleRow)
	if err != nil {
		rlbErr := tx.Rollback()
		if rlbErr != nil {
			return fmt.Errorf("sqle: multiple errors occurred: %q followed by tx.Rollback error: %q", err.Error(), rlbErr.Error())
		}

		return err
	}

	err = tx.Commit()
	if err != nil {
		return err
	}

	return nil
}

// SelectRangeTx is the same as `SelectRange` but uses the passed transaction
// `tx` to execute the statement.
func (s *Std) SelectRangeTx(ctx context.Context, tx *sql.Tx, query string, args []interface{}, dest []interface{}, handleRow func()) (err error) {
	if len(dest) == 0 {
		return fmt.Errorf("sqle: no dest to scan to")
	}

	var stmt *sql.Stmt
	stmt, err = tx.Prepare(query)
	if err != nil {
		return err
	}
	defer func() {
		closeErr := stmt.Close()
		if closeErr != nil && err == nil {
			err = closeErr
		}
	}()

	rows, err := stmt.QueryContext(ctx, args...)
	if err != nil {
		return err
	}

	for rows.Next() {
		err = rows.Scan(dest...)
		if err != nil {
			return err
		}

		handleRow()
	}
	if rows.Err() != nil {
		return err
	}

	return nil
}
