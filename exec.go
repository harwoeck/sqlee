package sqlee

import (
	"context"
	"database/sql"
)

// Exec will execute the query with it's argument against the database and
// returns any occurring errors.
func (s *Std) Exec(ctx context.Context, query string, args ...interface{}) error {
	_, err := s.ExecRes(ctx, query, args...)
	return err
}

// ExecTx is the same as `Exec` but uses the passed transaction `tx` to execute
// the operations.
func (s *Std) ExecTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) error {
	_, err := s.ExecResTx(ctx, tx, query, args...)
	return err
}

// ExecID executes the query with it's arguments against the database and
// returns any occurring errors.
//
// Additionally it returns the integer generated by the database in response to
// a command. Typically this will be from an "auto increment" column when
// inserting a new row. Not all databases support this feature, and the syntax
// of such statements varies.
func (s *Std) ExecID(ctx context.Context, query string, args ...interface{}) (lastInsertID int64, err error) {
	res, err := s.ExecRes(ctx, query, args...)
	if err != nil {
		return 0, err
	}

	lastInsertID, err = res.LastInsertId()
	if err != nil {
		return 0, err
	}

	return
}

// ExecIDTx is the same as `ExecID` but uses the passed transaction `tx` to
// execute the statement.
//
// Additionally it returns the integer generated by the database in response to
// a command. Typically this will be from an "auto increment" column when
// inserting a new row. Not all databases support this feature, and the syntax
// of such statements varies.
func (s *Std) ExecIDTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (lastInsertID int64, err error) {
	res, err := s.ExecResTx(ctx, tx, query, args...)
	if err != nil {
		return 0, err
	}

	lastInsertID, err = res.LastInsertId()
	if err != nil {
		return 0, err
	}

	return
}

// ExecAffected executes the query with it's arguments against the database and
// returns any occurring errors.
//
// Additionally it returns the number of rows affected by an update, insert, or
// delete. Not every database or database driver may support this.
func (s *Std) ExecAffected(ctx context.Context, query string, args ...interface{}) (rowsAffected int64, err error) {
	res, err := s.ExecRes(ctx, query, args...)
	if err != nil {
		return 0, err
	}

	rowsAffected, err = res.RowsAffected()
	if err != nil {
		return 0, err
	}

	return
}

// ExecAffectedTx is the same as `ExecAffected` but uses the passed transaction
// `tx` to execute the statement.
//
// Additionally it returns the number of rows affected by an update, insert, or
// delete. Not every database or database driver may support this.
func (s *Std) ExecAffectedTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (rowsAffected int64, err error) {
	res, err := s.ExecResTx(ctx, tx, query, args...)
	if err != nil {
		return 0, err
	}

	rowsAffected, err = res.RowsAffected()
	if err != nil {
		return 0, err
	}

	return
}

// ExecRes executes the query with it's arguments against the database and
// returns any occurring errors.
func (s *Std) ExecRes(ctx context.Context, query string, args ...interface{}) (sql.Result, error) {
	var res sql.Result
	var err error

	err = s.Tx(ctx, func(tx *sql.Tx) error {
		res, err = s.ExecResTx(ctx, tx, query, args...)
		if err != nil {
			return err
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	return res, nil
}

// ExecResTx is the same as `ExecRes` but uses the passed transaction `tx` to
// execute the statement.
func (s *Std) ExecResTx(ctx context.Context, tx *sql.Tx, query string, args ...interface{}) (res sql.Result, err error) {
	var stmt *sql.Stmt
	stmt, err = tx.PrepareContext(ctx, query)
	if err != nil {
		return nil, err
	}
	defer func() {
		closeErr := stmt.Close()
		if closeErr != nil && err == nil {
			res = nil
			err = closeErr
		}
	}()

	res, err = stmt.ExecContext(ctx, args...)
	if err != nil {
		return nil, err
	}

	return
}

// UnsafeExecBatch runs `Exec` without arguments for every entry in the
// `statements` collection.
//
// This method IS NOT SAFE AGAINST SQL-INJECTION. Use it only with trusted
// input!
func (s *Std) UnsafeExecBatch(ctx context.Context, statements []string) error {
	for _, stmt := range statements {
		err := s.Exec(ctx, stmt)
		if err != nil {
			return err
		}
	}

	return nil
}

// UnsafeExecBatchTx is the same as `UnsafeExecBatch` but uses the passed
// transaction `tx` to execute the statements.
//
// This method IS NOT SAFE AGAINST SQL-INJECTION. Use it only with trusted
// input!
func (s *Std) UnsafeExecBatchTx(ctx context.Context, tx *sql.Tx, statements []string) error {
	for _, stmt := range statements {
		err := s.ExecTx(ctx, tx, stmt)
		if err != nil {
			return err
		}
	}

	return nil
}
